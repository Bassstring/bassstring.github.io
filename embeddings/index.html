<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2D/3D Word Embeddings</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.18.2/plotly.min.js"></script>
  <!-- loads a local word2vec js object -->
  <script type="text/javascript" src="./word_vectors_15k.js" async></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      box-sizing: border-box;
      max-width: 100%;
      overflow-x: hidden;
    }

    #chart-container {
      width: 100%;
      max-width: 800px;
      height: 60vh;
      min-height: 300px;
    }

    input,
    button {
      margin: 10px 0;
      padding: 10px;
      width: 100%;
      max-width: 300px;
      font-size: 16px;
    }

    #loading {
      font-weight: bold;
      color: #007bff;
    }

    .toggle-container {
      display: flex;
      align-items: center;
      margin: 10px 0;
    }

    .toggle-label {
      margin: 0 10px;
      font-weight: bold;
    }

    .active-view {
      color: #2196F3;
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 30px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 20px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 24px;
      width: 24px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: #2196F3;
    }

    input:checked + .slider:before {
      transform: translateX(30px);
    }

    .word-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 20px;
    }

    .word-item {
      background-color: #f0f0f0;
      padding: 5px 10px;
      border-radius: 15px;
      display: flex;
      align-items: center;
    }

    .delete-word {
      margin-left: 5px;
      cursor: pointer;
      color: #ff0000;
      font-weight: bold;
    }

    @media (max-width: 600px) {
      body {
        padding: 10px;
      }

      h1 {
        font-size: 24px;
      }

      #chart-container {
        height: 50vh;
      }
    }
  </style>
</head>

<body>
  <h1 id="embeddings-title">2D Word Embeddings</h1>
  <div id="loading">Loading model...</div>
  <div id="chart-container" style="display: none;"></div>
  <input type="text" id="wordInput" placeholder="Enter a word" disabled>
  <button onclick="addWord()" disabled>Add Word</button>
  <div class="toggle-container">
    <span class="toggle-label" id="2d-label">2D</span>
    <label class="switch">
      <input type="checkbox" id="viewToggle" onchange="toggleView()">
      <span class="slider"></span>
    </label>
    <span class="toggle-label" id="3d-label">3D</span>
  </div>
  <div id="word-list" class="word-list"></div>
  <script>
    let model;
    let embeddings = [];
    const words = ['gehen', 'laufen', 'rennen'];
    let is3DView = false;

    async function loadModel() {
      await waitForWord2Vec();
      await updateEmbeddings();
      document.querySelector('button').disabled = false;
      document.getElementById('wordInput').disabled = false;
      document.getElementById('viewToggle').disabled = false;
      document.getElementById('loading').style.display = 'none';
      document.getElementById('chart-container').style.display = 'block';
      updateWordList();
      updateToggleLabels();
      updateTitle();
    }

    function waitForWord2Vec() {
      return new Promise((resolve) => {
        const checkWord2Vec = () => {
          if (typeof word2vec !== 'undefined') {
            resolve();
          } else {
            setTimeout(checkWord2Vec, 100);
          }
        };
        checkWord2Vec();
      });
    }

    async function getEmbeddings(words) {
      const embeddings = words.map(word => tf.tensor(word2vec[word]));
      return tf.stack(embeddings).arraySync()
    }

    function pca(data, k) {
      const dataTransposed = tf.transpose(data);
      const [q, r] = tf.linalg.qr(dataTransposed);
      const numDimensions = Math.min(k, q.shape[1]);
      const eigenVectors = q.slice([0, 0], [-1, numDimensions]);
      return tf.matMul(data, eigenVectors).arraySync();
    }

    async function updateEmbeddings() {
      embeddings = []; // Clear previous embeddings
      if (words.length === 0) {
        // If there are no words, clear the chart
        Plotly.purge('chart-container');
        return;
      }
      const embeddingsTensor = await getEmbeddings(words);
      const reducedEmbeddings = pca(embeddingsTensor, 3);
      embeddings = words.map((word, i) => ({
        word,
        embedding: reducedEmbeddings[i]
      }));
      updateChart();
    }

    function updateChart() {
      const data = is3DView ? prepare3DData() : prepare2DData();
      const layout = is3DView ? prepare3DLayout() : prepare2DLayout();
      Plotly.newPlot('chart-container', data, layout);
    }

    function prepare2DData() {
      return [{
        x: embeddings.map(e => e.embedding[0]),
        y: embeddings.map(e => e.embedding[1]),
        text: words,
        mode: 'markers+text',
        type: 'scatter',
        marker: {
          size: 10,
          color: embeddings.map((_, i) => i),
          colorscale: 'Viridis'
        },
        textposition: 'top center'
      }];
    }

    function prepare3DData() {
      return [{
        x: embeddings.map(e => e.embedding[0]),
        y: embeddings.map(e => e.embedding[1]),
        z: embeddings.map(e => e.embedding[2]),
        text: words,
        mode: 'markers+text',
        type: 'scatter3d',
        marker: {
          size: 5,
          color: embeddings.map((_, i) => i),
          colorscale: 'Viridis'
        },
        textposition: 'top center'
      }];
    }

    function prepare2DLayout() {
      return {
        title: '2D Word Embeddings',
        xaxis: {title: 'X'},
        yaxis: {title: 'Y'},
        margin: {l: 30, r: 30, b: 30, t: 30},
        autosize: true,
        responsive: true
      };
    }

    function prepare3DLayout() {
      return {
        title: '3D Word Embeddings',
        scene: {
          xaxis: {title: 'X'},
          yaxis: {title: 'Y'},
          zaxis: {title: 'Z'}
        },
        margin: {l: 0, r: 0, b: 0, t: 40},
        autosize: true,
        responsive: true
      };
    }

    async function addWord() {
      const newWord = document.getElementById('wordInput').value.trim().toLowerCase();
      if (!newWord) {
        // alert("Bitte geben Sie ein Wort ein.");
        return;
      }
      if (!word2vec.hasOwnProperty(newWord)) {
        alert(newWord + " ist leider nicht in diesem Datensatz enthalten.");
        return;
      }
      if (!words.includes(newWord)) {
        words.push(newWord);
        await updateEmbeddings();
        document.getElementById('wordInput').value = '';
        updateWordList();
        updateChart();
      }
    }

    function toggleView() {
      is3DView = document.getElementById('viewToggle').checked;
      updateChart();
      updateToggleLabels();
      updateTitle();
    }

    function updateTitle() {
      const title = is3DView ? '3D Word Embeddings' : '2D Word Embeddings';
      document.getElementById('embeddings-title').textContent = title;
    }

    function updateToggleLabels() {
      document.getElementById('2d-label').classList.toggle('active-view', !is3DView);
      document.getElementById('3d-label').classList.toggle('active-view', is3DView);
    }

    function updateWordList() {
      const wordList = document.getElementById('word-list');
      wordList.innerHTML = '';
      words.forEach((word, index) => {
        const wordItem = document.createElement('div');
        wordItem.className = 'word-item';
        wordItem.innerHTML = `${word} <span class="delete-word" onclick="deleteWord(${index})">Ã—</span>`;
        wordList.appendChild(wordItem);
      });
    }

    async function deleteWord(index) {
      words.splice(index, 1);
      await updateEmbeddings();
      updateWordList();
      if (words.length > 0) {
        updateChart();
      }
    }

    loadModel();
  </script>
</body>

</html>
